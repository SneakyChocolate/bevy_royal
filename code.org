#+title: Code

* lib.rs
** imports
#+begin_src rust :tangle src/lib.rs
pub use avian3d::prelude::*;
use bincode::{Decode, Encode};
pub use rand::Rng;
pub use bevy::window::PrimaryWindow;
pub use bevy::{
    core_pipeline::tonemapping::{DebandDither, Tonemapping},
    post_process::bloom::{Bloom, BloomCompositeMode},
    prelude::*,
};
#+end_src

** components
#+begin_src rust :tangle src/lib.rs
pub type NetIDType = u128;

#[derive(Resource)]
pub struct CursorPos(pub Vec2);

#[derive(Component, Clone, Copy)]
pub struct Velocity(pub Vec3);

#[derive(Component, Clone, Copy)]
pub struct Radius(pub f32);

#[derive(Component, Clone, Copy)]
pub struct Player;

#[derive(Component, Clone, Copy)]
pub struct Alive(pub bool);

#[derive(Component, Clone, Copy)]
pub struct Enemy;
#+end_src

** random functions
#+begin_src rust :tangle src/lib.rs
pub fn random_velocity(min: f32, max: f32) -> Vec3 {
    let mut rng = rand::rng();
    let angle = rng.random_range(0.0..std::f32::consts::TAU);
    let speed = rng.random_range(min..max);
    (Vec2::from_angle(angle) * speed).extend(0.)
}

pub fn random_position(range: f32) -> Vec2 {
    let mut rng = rand::rng();
    Vec2::new(
        rng.random_range(-range..range),
        rng.random_range(-range..range),
    )
}
#+end_src

** my data types
#+begin_src rust :tangle src/lib.rs
#[derive(Encode, Decode, Debug, Clone, Copy)]
pub struct MyVec3 {
    x: f32,
    y: f32,
    z: f32,
}

impl Into<Vec3> for MyVec3 {
    fn into(self) -> Vec3 {
        Vec3::new(self.x, self.y, self.z)
    }
}

impl Into<MyVec3> for Vec3 {
    fn into(self) -> MyVec3 {
        MyVec3 {
            x: self.x,
            y: self.y,
            z: self.z,
        }
    }
}

#[derive(Encode, Decode, Debug, Clone, Copy)]
pub struct MyQuat {
    x: f32,
    y: f32,
    z: f32,
    w: f32,
}

impl Into<Quat> for MyQuat {
    fn into(self) -> Quat {
        Quat::from_xyzw(self.x, self.y, self.z, self.w)
    }
}

impl Into<MyQuat> for Quat {
    fn into(self) -> MyQuat {
        MyQuat {
            x: self.x,
            y: self.y,
            z: self.z,
            w: self.w,
        }
    }
}

#[derive(Encode, Decode, Debug, Clone, Copy)]
pub struct MyVec2 {
    x: f32,
    y: f32,
}

impl Into<Vec2> for MyVec2 {
    fn into(self) -> Vec2 {
        Vec2::new(self.x, self.y)
    }
}

impl Into<MyVec2> for Vec2 {
    fn into(self) -> MyVec2 {
        MyVec2 {
            x: self.x,
            y: self.y,
        }
    }
}

#+end_src

** networking packages
#+begin_src rust :tangle src/lib.rs
#[derive(Encode, Decode, Debug, Clone)]
pub struct PositionPackage {
    pub net_id: NetIDType,
    pub position: MyVec3,
    pub rotation: MyQuat,
}

#[derive(Encode, Decode, Debug, Clone)]
pub struct VelocityPackage {
    pub net_id: NetIDType,
    pub velocity: MyVec3,
}

#[derive(Encode, Decode, Debug, Clone)]
pub struct EntityPackage {
    pub net_id: NetIDType,
    pub components: Vec<NetComponent>,
}

#[derive(Encode, Decode, Debug, Clone)]
pub struct ServerMessage {
    // 0 means not reliable, otherwise put id so that it can be confirmed, in bevy just put 1 and the network thread will automatically assign
    pub reliable: usize,
    pub message: ServerMessageInner,
}

impl ServerMessage {
    pub fn ok(reliable: usize, net_id: NetIDType) -> Self {
        Self {
            reliable,
            message: ServerMessageInner::Ok(net_id),
        }
    }
    pub fn spawn_entities(reliable: usize, packages: Vec<EntityPackage>) -> Self {
        Self {
            reliable,
            message: ServerMessageInner::SpawnEntities(packages),
        }
    }
    pub fn update_entities(reliable: usize, packages: Vec<EntityPackage>) -> Self {
        Self {
            reliable,
            message: ServerMessageInner::UpdateEntities(packages),
        }
    }
    pub fn update_positions(packages: Vec<PositionPackage>) -> Self {
        Self {
            reliable: 0,
            message: ServerMessageInner::UpdatePositions(packages),
        }
    }
    pub fn update_velocities(packages: Vec<VelocityPackage>) -> Self {
        Self {
            reliable: 0,
            message: ServerMessageInner::UpdateVelocities(packages),
        }
    }
}

#[derive(Encode, Decode, Debug, Clone)]
pub enum ServerMessageInner {
    Ok(NetIDType), // the id of the player so that it knows which id it is
    SpawnEntities(Vec<EntityPackage>),
    UpdateEntities(Vec<EntityPackage>),
    UpdatePositions(Vec<PositionPackage>),
    UpdateVelocities(Vec<VelocityPackage>),
}

impl ServerMessage {
    pub fn encode(&self) -> [u8; 1000] {
        let mut slice = [0u8; 1000];
        bincode::encode_into_slice(self, &mut slice, bincode::config::standard()).unwrap();
        slice
    }
    pub fn decode(slice: &[u8]) -> Option<Self> {
        let o = bincode::decode_from_slice(slice, bincode::config::standard());
        match o {
            Ok(r) => Some(r.0),
            Err(_) => None,
        }
    }
}

#[derive(Encode, Decode, Debug)]
pub enum ClientMessage {
    Login,
    SetVelocity(NetIDType, MyVec2),
    Rotation(NetIDType, MyQuat),
    Confirm(usize), // confirm an important message from the server, so the server doesnt resend (tcp immitation)
}

impl ClientMessage {
    pub fn encode(&self) -> [u8; 1000] {
        let mut slice = [0u8; 1000];
        bincode::encode_into_slice(self, &mut slice, bincode::config::standard()).unwrap();
        slice
    }
    pub fn decode(slice: &[u8]) -> Option<Self> {
        let o = bincode::decode_from_slice(slice, bincode::config::standard());
        match o {
            Ok(r) => Some(r.0),
            Err(_) => None,
        }
    }
}

// Define collision layers
#[derive(PhysicsLayer, Clone, Copy, Debug, Default)]
pub enum Layer {
    #[default]
    Boundary,
    Ball,
}

#[derive(Encode, Decode, Debug, Clone)]
pub enum NetComponent {
    LinearVelocity(MyVec3),
    Transform {
        translation: MyVec3,
        rotation: MyQuat,
        scale: MyVec3,
    },
    Sphere(f32),
    ColorMaterial {
        r: f32,
        g: f32,
        b: f32,
    },
    Alive(bool),
    Player,
    Enemy,
    Radius(f32),
    SpotLight(f32),
}

impl Into<NetComponent> for LinearVelocity {
    fn into(self) -> NetComponent {
        NetComponent::LinearVelocity((*self).into())
    }
}
impl Into<NetComponent> for Velocity {
    fn into(self) -> NetComponent {
        NetComponent::LinearVelocity((self.0).into())
    }
}
impl Into<NetComponent> for Transform {
    fn into(self) -> NetComponent {
        NetComponent::Transform {
            translation: self.translation.into(),
            rotation: self.rotation.into(), // TODO TEMP
            scale: self.scale.into(),
        }
    }
}
impl Into<NetComponent> for StandardMaterial {
    fn into(self) -> NetComponent {
        let color = self.base_color.to_srgba();
        NetComponent::ColorMaterial {
            r: color.red,
            g: color.green,
            b: color.blue,
        }
    }
}
impl Into<NetComponent> for Alive {
    fn into(self) -> NetComponent {
        NetComponent::Alive(self.0)
    }
}
impl Into<NetComponent> for Player {
    fn into(self) -> NetComponent {
        NetComponent::Player
    }
}
impl Into<NetComponent> for Enemy {
    fn into(self) -> NetComponent {
        NetComponent::Enemy
    }
}
impl Into<NetComponent> for Radius {
    fn into(self) -> NetComponent {
        NetComponent::Radius(self.0)
    }
}


impl NetComponent {
    pub fn apply_to(
        &self,
        entity: &mut EntityCommands,
        meshes: &mut ResMut<Assets<Mesh>>,
        materials: &mut ResMut<Assets<StandardMaterial>>,
    ) {
        match self {
            NetComponent::Transform { translation, rotation, scale } => {
                entity.insert(Transform {
                    translation: (*translation).into(),
                    rotation: (*rotation).into(),
                    scale: (*scale).into(),
                });
            },
            NetComponent::LinearVelocity(v) => {
                entity.insert(LinearVelocity((*v).into()));
                entity.insert(RigidBody::Dynamic);
            },
            NetComponent::Sphere(radius) => {
                entity.insert(Mesh3d(meshes.add(Sphere::new(*radius))));
            },
            NetComponent::ColorMaterial { r, g, b } => {
                entity.insert(MeshMaterial3d(materials.add(Color::srgb(*r, *g, *b))));
            },
            NetComponent::Alive(v) => {
                entity.insert(Alive(*v));
            },
            NetComponent::Player => {
                entity.insert(Player);
            },
            NetComponent::Enemy => {
                entity.insert(Enemy);
            },
            NetComponent::Radius(v) => {
                entity.insert(Radius(*v));
            },
            NetComponent::SpotLight(player_radius) => {
                entity.with_children(|parent| {
                    parent.spawn((
                        Transform::from_xyz(0.0, - player_radius * 6.5, player_radius * 5.5).looking_to(Vec3::Y, Vec3::Z),
                        SpotLight {
                            shadows_enabled: true,
                            intensity: player_radius * 10000000.,
                            range: player_radius * 100.,
                            shadow_depth_bias: 10.0,
                            ..default()
                        },
                    ));
                });
            }
        }
    }
}
#+end_src


* server.rs
** imports
#+begin_src rust :tangle src/bin/server.rs
use std::net::{SocketAddr, UdpSocket};
use std::collections::HashMap;
use bevy_royal::*;

pub struct ServerSocket {
    pub socket: UdpSocket,
    pub buf: [u8; 1000],
}

impl ServerSocket {
    pub fn new(
        socket: UdpSocket,
    ) -> Self {
        Self {
            socket,
            buf: [0; 1000],
        }
    }
    pub fn send_to(&self, bytes: &[u8], addr: SocketAddr) -> bool {
        match self.socket.send_to(bytes, addr) {
            Ok(l) => l == bytes.len(),
            Err(_) => false,
        }
    }
}

struct ReliablePackage {
    bytes: [u8; 1000],
    addr: SocketAddr,
    last_send: std::time::Instant,
}
#+end_src

** main
#+begin_src rust :tangle src/bin/server.rs
fn main() {
#+end_src

*** networking thread
#+begin_src rust :tangle src/bin/server.rs
    let (incoming_sender, incoming_receiver) = crossbeam::channel::unbounded::<(SocketAddr, ClientMessage)>();
    let (outgoing_sender, outgoing_receiver) = crossbeam::channel::unbounded::<(SocketAddr, ServerMessage)>();

    let _network_thread = std::thread::spawn(move || {
        let socket = UdpSocket::bind("0.0.0.0:7878").unwrap();
        socket.set_nonblocking(true).unwrap();
        let mut server_socket = ServerSocket::new(socket);

        let mut reliable_counter = 1;
        let mut reliable_packages = HashMap::<usize, ReliablePackage>::new();

        loop {
            // resend all important messegaes if they werent confirmed yet
            let now = std::time::Instant::now();
            for (_, packet) in reliable_packages.iter_mut() {
                if now.duration_since(packet.last_send) > std::time::Duration::from_millis(300) {
                    server_socket.send_to(&packet.bytes, packet.addr);
                    packet.last_send = now;
                }
            }

            // get from game
            while let Ok((addr, mut outgoing_package)) = outgoing_receiver.try_recv() {
                if outgoing_package.reliable > 0 {
                    outgoing_package.reliable = reliable_counter;
                }
                let bytes = outgoing_package.encode();
                if outgoing_package.reliable > 0 {
                    reliable_packages.insert(reliable_counter, ReliablePackage {
                        bytes,
                        addr,
                        last_send: now,
                    });
                    reliable_counter += 1;
                }
                server_socket.send_to(&bytes, addr);
            }

            // get from socket
            let ServerSocket { socket, buf } = &mut server_socket;

            while let Ok((len, addr)) = socket.recv_from(buf) {
                if let Some(client_message) = ClientMessage::decode(&buf[..len]) {
                    if let ClientMessage::Confirm(reliable) = &client_message {
                        reliable_packages.remove(reliable);
                    }
                    incoming_sender.send((addr, client_message)).unwrap();
                }
            }

            std::thread::sleep(std::time::Duration::from_millis(1));
        }
    });

#+end_src

*** bevy app
#+begin_src rust :tangle src/bin/server.rs
    App::new()
        .insert_resource(IncomingReceiver(incoming_receiver))
        .insert_resource(OutgoingSender(outgoing_sender))
        // .insert_resource(Gravity(Vec3::NEG_Z))
        .insert_resource(Gravity::ZERO)
        .insert_resource(IDCounter(0))
        .insert_resource(EntityMap::default())
        .insert_resource(NetIDMap::default())
        .add_plugins(DefaultPlugins)
        .add_plugins(PhysicsPlugins::default())
        .add_systems(Startup, (
            setup,
            spawn_enemies,
            spawn_walls,
        ))
        .add_systems(Update, (
            receive_messages,
            apply_velocity_system,
            enemy_kill_system,
            broadcast_enemy_spawns,
            broadcast_player_spawns,
            broadcast_positions,
            broadcast_velocities,
        ))
        .run();
}
#+end_src

** components and resources
#+begin_src rust :tangle src/bin/server.rs

#[derive(Resource)]
pub struct IncomingReceiver(crossbeam::channel::Receiver<(SocketAddr, ClientMessage)>);

#[derive(Resource)]
pub struct OutgoingSender(crossbeam::channel::Sender<(SocketAddr, ServerMessage)>);

#[derive(Resource, Default)]
struct NetIDMap(HashMap<Entity, NetIDType>);

#[derive(Resource, Default)]
struct EntityMap(HashMap<NetIDType, Entity>);

#[derive(Resource)]
struct IDCounter(pub NetIDType);

#[derive(Component)]
pub struct LastBroadcast(pub HashMap<SocketAddr, f32>);

#[derive(Component)]
struct PendingSpawn;

#[derive(Component)]
pub struct UpdateAddress {
    addr: SocketAddr,
}

#+end_src

** receive messages
#+begin_src rust :tangle src/bin/server.rs
fn receive_messages(
    incoming_receiver: Res<IncomingReceiver>,
    outgoing_sender: Res<OutgoingSender>,
    mut commands: Commands,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
    mut id_counter: ResMut<IDCounter>,
    mut net_id_map: ResMut<NetIDMap>,
    mut entity_map: ResMut<EntityMap>,
    mut player_query: Query<(&mut Velocity, &mut Transform), With<Player>>,
    client_addresses: Query<Entity, With<UpdateAddress>>,
) {
    while let Ok((addr, client_message)) = incoming_receiver.0.try_recv() {
        match client_message {
            ClientMessage::Confirm(_) => {},
            ClientMessage::Login => {
                // spawn player
                let player_radius = 1.5;
                let id = commands.spawn((
                    Transform::from_xyz(0., 0., player_radius),
                    Player,
                    Alive(true),
                    Radius(player_radius),
                    Velocity(Vec3::ZERO),
                    // LinearVelocity(Vec2::new(-200., 0.)),
                    // RigidBody::Dynamic,
                    Mesh3d(meshes.add(Sphere::new(player_radius))),
                    MeshMaterial3d(materials.add(Color::srgb(0., 1., 0.))),
                    UpdateAddress {addr},
                    PendingSpawn,
                    LastBroadcast(HashMap::new()),
                )).id();

                net_id_map.0.insert(id, id_counter.0);
                entity_map.0.insert(id_counter.0, id);
                outgoing_sender.0.send((addr, ServerMessage::ok(1, id_counter.0))).unwrap();

                id_counter.0 += 1;

                // give all clients pending spawn
                for client in client_addresses {
                    commands.entity(client).insert(PendingSpawn);
                }
            },
            ClientMessage::SetVelocity(player_net_id, velocity) => {
                let player_entity_option = entity_map.0.get(&player_net_id);
                let mut player_exists = false;
                match player_entity_option {
                    Some(player_entity) => {
                        if let Ok((mut player_velocity, _)) = player_query.get_mut(*player_entity) {
                            player_exists = true;
                            player_velocity.0 = Into::<Vec2>::into(velocity).extend(0.);
                        }
                    },
                    None => {},
                }
                if !player_exists {
                    entity_map.0.remove(&player_net_id);
                }
            },
            ClientMessage::Rotation(player_net_id, rotation) => {
                let player_entity_option = entity_map.0.get(&player_net_id);
                let mut player_exists = false;
                match player_entity_option {
                    Some(player_entity) => {
                        if let Ok((_, mut player_transform)) = player_query.get_mut(*player_entity) {
                            player_exists = true;
                            player_transform.rotation = rotation.into();
                        }
                    },
                    None => {},
                }
                if !player_exists {
                    entity_map.0.remove(&player_net_id);
                }
            }
        }
    }
}

#+end_src

** send messages
#+begin_src rust :tangle src/bin/server.rs
fn broadcast_player_spawns(
    outgoing_sender: Res<OutgoingSender>,
    mut commands: Commands,
    materials: ResMut<Assets<StandardMaterial>>,
    net_id_map: ResMut<NetIDMap>,
    client_addresses: Query<(Entity, &UpdateAddress), With<PendingSpawn>>,
    player_query: Query<(Entity, &Transform, &Velocity, &MeshMaterial3d<StandardMaterial>, &Player, &Alive, &Radius)>,
) {
    for (id, addr) in client_addresses.iter() {
        // println!("client spawn");
        let mut entity_packages = Vec::<EntityPackage>::new();
        for (entity, transform, velocity, meshmaterial3d, player, alive, radius) in &player_query {
            println!("player broadcast");
            let net_id = net_id_map.0.get(&entity).unwrap();
            entity_packages.push(EntityPackage { net_id: *net_id, components: vec![
                (*transform).into(),
                NetComponent::Sphere(radius.0),
                (*transform).into(),
                (*velocity).into(),
                (materials.get(meshmaterial3d).unwrap().clone()).into(),
                (*player).into(),
                (*alive).into(),
                (*radius).into(),
                NetComponent::SpotLight(radius.0),
            ] });
        }
        for chonky in entity_packages.chunks(2) {
            outgoing_sender.0.send((addr.addr, ServerMessage::spawn_entities(1, chonky.to_vec()))).unwrap();
        }
        println!("sending player spawn");
        commands.entity(id).remove::<PendingSpawn>();
    }
}

fn broadcast_enemy_spawns(
    outgoing_sender: Res<OutgoingSender>,
    materials: ResMut<Assets<StandardMaterial>>,
    net_id_map: ResMut<NetIDMap>,
    client_addresses: Query<(Entity, &UpdateAddress), With<PendingSpawn>>,
    enemy_query: Query<(Entity, &Transform, &LinearVelocity, &MeshMaterial3d<StandardMaterial>, &Enemy, &Radius)>,
) {
    for (_, addr) in client_addresses.iter() {
        let mut entity_packages = Vec::<EntityPackage>::new();
        for (entity, transform, velocity, meshmaterial3d, enemy, radius) in &enemy_query {
            let net_id = net_id_map.0.get(&entity).unwrap();
            entity_packages.push(EntityPackage { net_id: *net_id, components: vec![
                (*transform).into(),
                NetComponent::Sphere(radius.0),
                (*transform).into(),
                (*velocity).into(),
                (materials.get(meshmaterial3d).unwrap().clone()).into(),
                (*enemy).into(),
                (*radius).into(),
            ] });
        }
        for chonky in entity_packages.chunks(5) {
            outgoing_sender.0.send((addr.addr, ServerMessage::spawn_entities(1, chonky.to_vec()))).unwrap();
            // commands.entity(id).remove::<PendingSpawn>();
        }
    }
}

const POSITION_PACKAGES_PER_MESSAGE: usize = (1000. / std::mem::size_of::<PositionPackage>() as f32).floor() as usize;
const VELOCITY_PACKAGES_PER_MESSAGE: usize = (1000. / std::mem::size_of::<VelocityPackage>() as f32).floor() as usize;

fn update_per_distance(
    addr: SocketAddr,
    delta_secs: f32,
    last_broadcast_option: Option<Mut<LastBroadcast>>,
    distance: f32,
) -> bool {
    if let Some(mut last_broadcast) = last_broadcast_option {
        let mut lb = last_broadcast.0.entry(addr).or_insert(0.);
        *lb += delta_secs;
        if *lb >= distance / 200. {
            *lb = 0.0;
            true
        }
        else {
            false
        }
    }
    else {
        false
    }
}

fn broadcast_positions(
    outgoing_sender: Res<OutgoingSender>,
    client_addresses: Query<(Entity, &UpdateAddress, &Transform)>,
    mut query: Query<(Entity, &Transform, Option<&mut LastBroadcast>)>,
    net_id_map: ResMut<NetIDMap>,
    time: Res<Time>,
) {
    let delta_secs = time.delta_secs();

    // Process each client separately
    for (_entity, addr, player_transform) in client_addresses.iter() {
        let player_pos = player_transform.translation;

        // Collect enemies within radius for this specific player
        let nearby_entities: Vec<PositionPackage> = query
            .iter_mut()
            .filter_map(|(entity, entity_transform, last_broadcast_option)| {
                let distance = player_pos.distance(entity_transform.translation);
                let net_id = net_id_map.0.get(&entity)?;

                if update_per_distance(addr.addr, delta_secs, last_broadcast_option, distance) {
                    Some(PositionPackage {
                        net_id: *net_id,
                        position: entity_transform.translation.into(),
                        rotation: entity_transform.rotation.into(),
                    })
                }
                else {
                    None
                }
            })
            .collect();

        // Split into chunks and send
        for chunk in nearby_entities.chunks(POSITION_PACKAGES_PER_MESSAGE) {
            let message = ServerMessage::update_positions(chunk.to_vec());
            outgoing_sender.0.send((addr.addr, message)).unwrap();
        }
    }
}

fn broadcast_velocities(
    outgoing_sender: Res<OutgoingSender>,
    client_addresses: Query<(Entity, &UpdateAddress, &Transform)>,
    mut query: Query<(Entity, &Transform, &LinearVelocity, Option<&mut LastBroadcast>)>,
    net_id_map: ResMut<NetIDMap>,
    time: Res<Time>,
) {
    let delta_secs = time.delta_secs();

    // Process each client separately
    for (_entity, addr, player_transform) in client_addresses.iter() {
        let player_pos = player_transform.translation;

        // Collect enemies within radius for this specific player
        let nearby_entities: Vec<VelocityPackage> = query
            .iter_mut()
            .filter_map(|(entity, entity_transform, entity_velocity, last_broadcast_option)| {
                let distance = player_pos.distance(entity_transform.translation);
                let net_id = net_id_map.0.get(&entity)?;

                if update_per_distance(addr.addr, delta_secs, last_broadcast_option, distance) {
                    Some(VelocityPackage {
                        net_id: *net_id,
                        velocity: entity_velocity.0.into(),
                    })
                }
                else {
                    None
                }
            })
            .collect();

        // Split into chunks and send
        for chunk in nearby_entities.chunks(VELOCITY_PACKAGES_PER_MESSAGE) {
            let message = ServerMessage::update_velocities(chunk.to_vec());
            outgoing_sender.0.send((addr.addr, message)).unwrap();
        }
    }
}

#+end_src

** setup
#+begin_src rust :tangle src/bin/server.rs
fn setup(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut meshes: ResMut<Assets<Mesh>>,
    mut standard_materials: ResMut<Assets<StandardMaterial>>,
) {
    commands.insert_resource(AmbientLight {
        brightness: 50.,
        ..Default::default()
    });

    commands.spawn((
        Camera3d::default(),
        Camera {
            clear_color: ClearColorConfig::Custom(Color::BLACK),
            ..default()
        },
        Transform::from_xyz(0., 0., 500.).looking_at(Vec3::ZERO, Vec3::Y),
        Tonemapping::TonyMcMapface,
        Bloom::default(),
        DebandDither::Enabled,
    ));
    commands.spawn((
        Mesh3d(meshes.add(Plane3d::default().mesh().size(2000.0, 2000.0).subdivisions(10))),
        MeshMaterial3d(standard_materials.add(Color::srgb(0.4, 0.5, 0.1))),
        Transform::from_rotation(Quat::from_rotation_x(std::f32::consts::FRAC_PI_2)).with_translation(Vec3::new(0., 0., 0.)),
    ));

    commands.spawn((
        ColliderConstructorHierarchy::new(ColliderConstructor::TrimeshFromMesh),
        CollisionLayers::new([Layer::Boundary], [Layer::Ball]),

        SceneRoot(asset_server.load(
            GltfAssetLabel::Scene(0).from_asset("fiebigershof.glb"),
        )),
        Transform::from_xyz(20., -20., 0.)
            .with_rotation(Quat::from_rotation_x(std::f32::consts::FRAC_PI_2))
            .with_scale(Vec3::splat(50.))
        ,
    ));
}

const HALF_BOUNDARY: f32 = 1000.0;

fn spawn_walls(
    mut commands: Commands,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
) {
    let mut rng = rand::rng();
    // + Spawn static boundary colliders
    let thickness = 10.0;
    let wall_material = MeshMaterial3d(materials.add(Color::srgb(
        rng.random_range(0.0..4.0),
        rng.random_range(0.0..4.0),
        rng.random_range(0.0..4.0),
    )));
    for &pos in &[-HALF_BOUNDARY, HALF_BOUNDARY] {
        // spawn vertical walls
        commands.spawn((
            Mesh3d(meshes.add(Cuboid::new(thickness, HALF_BOUNDARY * 2., 5.))),
            wall_material.clone(),
            Transform::from_xyz(pos, 0., 0.),
            RigidBody::Static,
            Collider::cuboid(thickness, HALF_BOUNDARY * 2., 5.),
            CollisionLayers::new([Layer::Boundary], [Layer::Ball]),
        ));
        // spawn horizontal walls
        commands.spawn((
            Mesh3d(meshes.add(Cuboid::new(HALF_BOUNDARY * 2., thickness, 5.))),
            wall_material.clone(),
            Transform::from_xyz(0., pos, 0.),
            RigidBody::Static,
            Collider::cuboid(HALF_BOUNDARY * 2., thickness, 5.),
            CollisionLayers::new([Layer::Boundary], [Layer::Ball]),
        ));
    }
}

fn spawn_enemies(
    mut commands: Commands,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
    mut id_counter: ResMut<IDCounter>,
    mut net_id_map: ResMut<NetIDMap>,
    mut entity_map: ResMut<EntityMap>,
) {
    let mut rng = rand::rng();

    for _ in 0..2000 {
        let velocity = LinearVelocity(random_velocity(3., 9.));
        let position = random_position(HALF_BOUNDARY);
        let material = MeshMaterial3d(materials.add(Color::srgb(
            rng.random_range(0.0..4.0),
            rng.random_range(0.0..4.0),
            rng.random_range(0.0..4.0),
        )));

        let enemy_radius = rng.random_range(1.0..2.0);

        // spawn enemy
        let id = commands.spawn((
            Transform::from_translation(position.extend(enemy_radius)),
            Mesh3d(meshes.add(Sphere::new(enemy_radius))),
            material,
            RigidBody::Dynamic,
            Collider::sphere(enemy_radius),
            velocity,
            CollisionLayers::new([Layer::Ball], [Layer::Boundary]),
            Restitution::new(1.0), // Perfect bounce (1.0 = 100% energy retained)
            Friction::ZERO.with_combine_rule(CoefficientCombine::Min), // Remove friction
            Enemy,
            Radius(enemy_radius),
            LastBroadcast(HashMap::new()),
        )).id();

        net_id_map.0.insert(id, id_counter.0);
        entity_map.0.insert(id_counter.0, id);
        id_counter.0 += 1;
    }
}

#+end_src

** gameplay
#+begin_src rust :tangle src/bin/server.rs
fn apply_velocity_system(
    time: Res<Time>,
    query: Query<(&mut Transform, &Velocity)>,
) {
    let d = time.delta_secs();
    for (mut transform, velocity) in query {
        transform.translation += velocity.0 * d;
    }
}

fn enemy_kill_system(
    players: Query<(&mut Alive, &Transform, &Radius), With<Player>>,
    enemies: Query<(&Transform, &Radius), With<Enemy>>,
) {
    for (mut player_alive, player_pos, player_radius) in players {
        for (enemy_pos, enemy_radius) in enemies {
            let distance = player_pos.translation.distance(enemy_pos.translation);
            if distance - player_radius.0 - enemy_radius.0 <= 0. {
                player_alive.0 = false;
            }
        }
    }
}

#+end_src


* client.rs
** imports
#+begin_src rust :tangle src/bin/client.rs
use std::net::UdpSocket;
use std::collections::HashMap;
use bevy::window::{CursorGrabMode, CursorOptions};
use bevy_royal::*;
// use bevy_inspector_egui::{bevy_egui::EguiPlugin, quick::WorldInspectorPlugin};
use bevy::{
    input::mouse::AccumulatedMouseMotion,
};
use std::f32::consts::FRAC_PI_2;
#+end_src

** components and resources
#+begin_src rust :tangle src/bin/client.rs

const FOG_COLOR: Color = Color::srgb(0.15, 0.20, 0.30);

#[derive(Resource)]
pub struct IncomingReceiver(crossbeam::channel::Receiver<ServerMessage>);
#[derive(Resource)]
pub struct OutgoingSender(crossbeam::channel::Sender<ClientMessage>);
#[derive(Resource, Default)]
struct NetIDMap(HashMap<Entity, NetIDType>);
#[derive(Resource, Default)]
struct EntityMap(HashMap<NetIDType, Entity>);

#[derive(Component)]
struct Controlled;

#[derive(Debug, Component)]
struct Player;

#[derive(Debug, Component, Deref, DerefMut)]
struct CameraSensitivity(Vec2);

impl Default for CameraSensitivity {
    fn default() -> Self {
        Self(
            Vec2::new(0.003, 0.003),
        )
    }
}

#+end_src

** main
#+begin_src rust :tangle src/bin/client.rs
pub struct ClientSocket {
    pub target: String,
    pub socket: UdpSocket,
    pub buf: [u8; 1000],
}

impl ClientSocket {
    pub fn new(target: String) -> Self {
        let socket = UdpSocket::bind("0.0.0.0:0").unwrap();
        socket.set_nonblocking(true).unwrap();
        Self {
            socket,
            buf: [0; 1000],
            target,
        }
    }
    pub fn send(&self, bytes: &[u8]) {
        self.socket.send_to(bytes, &self.target)/* .unwrap() */;
    }
}

fn main() {
    let args: Vec<String> = std::env::args().collect();
    let server_address = args.get(1).cloned().unwrap_or("127.0.0.1:7878".to_string());

    let (incoming_sender, incoming_receiver) = crossbeam::channel::unbounded::<ServerMessage>();
    let (outgoing_sender, outgoing_receiver) = crossbeam::channel::unbounded::<ClientMessage>();

    let _network_thread = std::thread::spawn(move || {
        let mut client_socket = ClientSocket::new(server_address);
        let mut delay_pool: Vec<(f32, ServerMessage)> = Vec::with_capacity(1000);
        let mut past = std::time::Instant::now();

        loop {
            // delta time
            let present = std::time::Instant::now();
            let delta_secs = present.duration_since(past).as_secs_f32();
            past = present;

            // get from game
            while let Ok(outgoing_package) = outgoing_receiver.try_recv() {
                let bytes = outgoing_package.encode();
                client_socket.send(&bytes);
            }

            // get from socket
            let ClientSocket { socket, buf, target: _ } = &mut client_socket;

            while let Ok((len, _addr)) = socket.recv_from(buf) {
                if let Some(server_message) = ServerMessage::decode(&buf[..len]) {
                    // incoming_sender.send(server_message);
                    delay_pool.push((0.0, server_message));
                }
                else {
                    println!("got something that couldnt be decoded");
                }
            }

            // go through delay pool
            let mut removed = Vec::<ServerMessage>::new();
            delay_pool.retain_mut(|(d, sm)| {
                ,*d -= delta_secs;
                if *d < 0. {
                    removed.push(sm.clone());
                    false
                }
                else {
                    true
                }
            });

            for server_message in removed {
                incoming_sender.send(server_message).unwrap();
            }
        }
    });

    App::new()
        .insert_resource(IncomingReceiver(incoming_receiver))
        .insert_resource(OutgoingSender(outgoing_sender))
        .insert_resource(CursorPos(Vec2::ZERO))
        .insert_resource(EntityMap::default())
        .insert_resource(NetIDMap::default())
        .insert_resource(Gravity::ZERO)
        .add_plugins(DefaultPlugins)
        // .add_plugins(EguiPlugin::default())
        // .add_plugins(WorldInspectorPlugin::new())
        .add_plugins(PhysicsPlugins::default())
        .add_systems(Startup, (setup, cursor_lock))
        .add_systems(Update, (
            receive_messages,
            cursor_position_system,
            rotate_player,
            player_movement_system,
        ))
        .run();
}
#+end_src

** setup
#+begin_src rust :tangle src/bin/client.rs


fn setup(
    outgoing_sender: Res<OutgoingSender>,
    mut commands: Commands,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
    asset_server: Res<AssetServer>,
) {
    let login_message = ClientMessage::Login;
    outgoing_sender.0.send(login_message).unwrap();

    let mut rng = rand::rng();
    // + Spawn static boundary colliders
    let half_boundary = 3000.0;
    let thickness = 10.0;
    let wall_material = MeshMaterial3d(materials.add(Color::srgb(
        rng.random_range(0.0..4.0),
        rng.random_range(0.0..4.0),
        rng.random_range(0.0..4.0),
    )));
    for &pos in &[-half_boundary, half_boundary] {
        // spawn vertical walls
        commands.spawn((
            Mesh3d(meshes.add(Cuboid::new(thickness, half_boundary * 2., 5.))),
            wall_material.clone(),
            Transform::from_xyz(pos, 0., 0.),
            RigidBody::Static,
            Collider::cuboid(thickness, half_boundary * 2., 5.),
            CollisionLayers::new([Layer::Boundary], [Layer::Ball]),
        ));
        // spawn horizontal walls
        commands.spawn((
            Mesh3d(meshes.add(Cuboid::new(half_boundary * 2., thickness, 5.))),
            wall_material.clone(),
            Transform::from_xyz(0., pos, 0.),
            RigidBody::Static,
            Collider::cuboid(half_boundary * 2., thickness, 5.),
            CollisionLayers::new([Layer::Boundary], [Layer::Ball]),
        ));
    }

    commands.spawn((
        SceneRoot(asset_server.load(
            GltfAssetLabel::Scene(0).from_asset("fiebigershof.glb"),
        )),
        Transform::from_xyz(20., -20., 0.)
            .with_rotation(Quat::from_rotation_x(std::f32::consts::FRAC_PI_2))
            .with_scale(Vec3::splat(50.))
        ,
    ));
}

#+end_src

** client input
#+begin_src rust :tangle src/bin/client.rs
fn cursor_position_system(
    window: Single<&Window, With<PrimaryWindow>>,
    mut cursor: ResMut<CursorPos>,
) {
    let window_center = Vec2::new(window.width() / 2.0, window.height() / 2.0);

    if let Some(cursor_position) = window.cursor_position() {
        cursor.0 = (cursor_position - window_center) * Vec2::new(1., -1.); // relative to center
    }
}

fn player_movement_system(
    keyboard: Res<ButtonInput<KeyCode>>,
    mut player_query: Query<(Entity, &mut Velocity, &Alive, &Transform), (With<Player>, With<Controlled>)>,
    outgoing_sender: Res<OutgoingSender>,
    net_id_map: Res<NetIDMap>,
) {
    let speed = 80.0;

    for (player_entity, mut velocity, alive, camera_transform) in player_query.iter_mut() {
        let (yaw, _pitch, _roll) = camera_transform.rotation.to_euler(EulerRot::ZXY);

        let yaw_rotation = Quat::from_axis_angle(Vec3::Z, yaw);

        let forward = yaw_rotation * Vec3::Y;
        let forward_2d = Vec2::new(forward.x, forward.y).normalize_or_zero();

        let right_2d = Vec2::new(-forward_2d.y, forward_2d.x);

        if alive.0 {
            let mut dir = Vec2::ZERO;

            if keyboard.pressed(KeyCode::KeyW) { dir += forward_2d; }
            if keyboard.pressed(KeyCode::KeyS) { dir -= forward_2d; }
            if keyboard.pressed(KeyCode::KeyA) { dir += right_2d; }
            if keyboard.pressed(KeyCode::KeyD) { dir -= right_2d; }

            if dir.length_squared() > 0.0 {
                dir = dir.normalize();
            }

            velocity.0 = (dir * speed).extend(0.);
        } else {
            velocity.0 = Vec3::ZERO;
        }

        let net_id = net_id_map.0.get(&player_entity).unwrap();
        outgoing_sender.0.send(ClientMessage::SetVelocity(*net_id, velocity.0.truncate().into())).unwrap();
    }
}


fn rotate_player(
    accumulated_mouse_motion: Res<AccumulatedMouseMotion>,
    player: Single<(Entity, &mut Transform, &CameraSensitivity), With<Controlled>>,
    outgoing_sender: Res<OutgoingSender>,
    net_id_map: Res<NetIDMap>,
) {
    let (player_entity, mut transform, camera_sensitivity) = player.into_inner();

    let delta = accumulated_mouse_motion.delta;

    if delta != Vec2::ZERO {
        let delta_yaw = -delta.x * camera_sensitivity.x;
        let delta_pitch = -delta.y * camera_sensitivity.y;

        let (yaw, pitch, roll) = transform.rotation.to_euler(EulerRot::ZXY);
        let yaw = yaw + delta_yaw;

        const PITCH_LIMIT: f32 = FRAC_PI_2 - 0.01;
        let pitch = (pitch + delta_pitch).clamp(-PITCH_LIMIT, PITCH_LIMIT);

        let new_rotation = Quat::from_euler(EulerRot::ZXY, yaw, pitch, roll);
        transform.rotation = new_rotation;

        let net_id = net_id_map.0.get(&player_entity).unwrap();
        outgoing_sender.0.send(ClientMessage::Rotation(*net_id, new_rotation.into())).unwrap();
    }
}

#+end_src

** receive messages
#+begin_src rust :tangle src/bin/client.rs
fn receive_messages(
    incoming_receiver: Res<IncomingReceiver>,
    outgoing_sender: Res<OutgoingSender>,
    mut commands: Commands,
    mut meshes: ResMut<Assets<Mesh>>,
    mut standard_materials: ResMut<Assets<StandardMaterial>>,
    mut entity_map: ResMut<EntityMap>,
    mut net_id_map: ResMut<NetIDMap>,
    mut transform_query: Query<(Entity, &mut Transform, Has<Controlled>)>,
    mut velocity_query: Query<(Entity, &mut LinearVelocity, Has<Controlled>)>,
) {

    loop {
        match incoming_receiver.0.try_recv() {
            Ok(ServerMessage {
                reliable,
                message,
            }) => {
                if reliable > 0 {
                    outgoing_sender.0.send(ClientMessage::Confirm(reliable));
                }
                match message {
                    ServerMessageInner::SpawnEntities(entity_packages) => {
                        for EntityPackage { net_id, components } in entity_packages {
                            if let Some(_) = entity_map.0.get(&net_id) {
                                // already exists
                            }
                            else {
                                let mut entity = commands.spawn(( ));

                                for component in components {
                                    component.apply_to(&mut entity, &mut meshes, &mut standard_materials);
                                }

                                let id = entity.id();
                                entity_map.0.insert(net_id, id);
                                net_id_map.0.insert(id, net_id);
                            }
                        }
                    },
                    ServerMessageInner::UpdateEntities(entity_packages) => {
                        for EntityPackage { net_id, components } in entity_packages {
                            if let Some(entity) = entity_map.0.get(&net_id) {
                                if let Ok(mut entity_commands) = commands.get_entity(*entity) {
                                    for component in components {
                                        component.apply_to(&mut entity_commands, &mut meshes, &mut standard_materials);
                                    }
                                }
                            }
                        }
                    },
                    // receiv myself
                    ServerMessageInner::Ok(net_id) => {
                        if !entity_map.0.contains_key(&net_id) {
                            println!("player was created successfully with id {:?}", net_id);

                            commands.insert_resource(AmbientLight {
                                brightness: 1.,
                                ..Default::default()
                            });

                            // sun
                            // commands.spawn((
                            //     DirectionalLight {
                            //         illuminance: 320.0,
                            //         ..default()
                            //     },
                            //     Transform::from_xyz(0.0, 2.0, 0.0).with_rotation(Quat::from_rotation_x(-PI / 4.)),
                            // ));

                            commands.spawn((
                                Mesh3d(meshes.add(Plane3d::default().mesh().size(2000.0, 2000.0).subdivisions(10))),
                                MeshMaterial3d(standard_materials.add(Color::srgb(0.4, 0.5, 0.1))),
                                Transform::from_rotation(Quat::from_rotation_x(std::f32::consts::FRAC_PI_2)).with_translation(Vec3::new(0., 0., 0.)),
                            ));

                            // spawn player
                            let player_radius = 1.5;
                            let id = commands.spawn((
                                Mesh3d(meshes.add(Sphere::new(player_radius))),
                                Transform::default() ,
                                Velocity(Vec3::ZERO),
                                MeshMaterial3d(standard_materials.add(Color::srgb(0., 1., 0.))),
                                Player,
                                Alive(true),
                                Radius(player_radius),
                                Controlled,
                                CameraSensitivity::default(),

                                children![
                                    (
                                        Camera3d::default(),
                                        Camera {
                                            clear_color: ClearColorConfig::Custom(FOG_COLOR),
                                            ..default()
                                        },
                                        DistanceFog {
                                            color: FOG_COLOR,
                                            falloff: FogFalloff::Linear {
                                                start: player_radius * 10.,
                                                end: player_radius * 100.,
                                            },
                                            ..default()
                                        },

                                        Projection::from(PerspectiveProjection {
                                            fov: 90.0_f32.to_radians(),
                                            ..default()
                                        }),
                                        Transform::from_xyz(0.0, - player_radius * 2.5, player_radius * 1.5).looking_to(Vec3::Y, Vec3::Z),

                                        Tonemapping::TonyMcMapface,
                                        Bloom::default(),
                                        DebandDither::Enabled,
                                    ),
                                    (
                                        Transform::from_xyz(0.0, - player_radius * 6.5, player_radius * 5.5).looking_to(Vec3::Y, Vec3::Z),
                                        SpotLight {
                                            shadows_enabled: true,
                                            intensity: player_radius * 10000000.,
                                            range: player_radius * 100.,
                                            shadow_depth_bias: 10.0,
                                            ..default()
                                        },
                                        // PointLight {
                                        //     shadows_enabled: true,
                                        //     intensity: 1000000000.,
                                        //     range: 3000.0,
                                        //     shadow_depth_bias: 10.0,
                                        //     ..default()
                                        // },
                                    ),
                                ],
                            )).id();

                            entity_map.0.insert(net_id, id);
                            net_id_map.0.insert(id, net_id);
                        }
                    },
                    ServerMessageInner::UpdatePositions(position_packages) => {
                        for position_package in position_packages {
                            if let Some(entity) = entity_map.0.get(&position_package.net_id) {
                                if let Ok((_, mut transform, controlled)) = transform_query.get_mut(*entity) {
                                    transform.translation = position_package.position.clone().into();
                                    if !controlled {
                                        transform.rotation = position_package.rotation.clone().into();
                                    }
                                }
                            }
                        }
                    },
                    ServerMessageInner::UpdateVelocities(velocity_packages) => {
                        for package in velocity_packages {
                            if let Some(entity) = entity_map.0.get(&package.net_id) {
                                if let Ok((_, mut velocity, controlled)) = velocity_query.get_mut(*entity) {
                                    if !controlled {
                                        velocity.0 = package.velocity.into();
                                    }
                                }
                            }
                        }
                    },
                }
            }
            Err(e) => match e {
                crossbeam::channel::TryRecvError::Empty => break,
                crossbeam::channel::TryRecvError::Disconnected => break,
            },
        }
    }
}


#+end_src

** other
#+begin_src rust :tangle src/bin/client.rs
fn cursor_lock(
    mut cursor_options: Single<&mut CursorOptions, With<PrimaryWindow>>,
) {
    cursor_options.grab_mode = CursorGrabMode::Locked;
    cursor_options.visible = false;
}

// TEMP
fn print_enemy_count(
    enemies: Query<Entity, With<Enemy>>,
) {
    let count = enemies.iter().count();
    println!("enemeis: {count}");
}

#+end_src
